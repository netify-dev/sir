% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{cpp_tprod_A_X_Bt}
\alias{cpp_tprod_A_X_Bt}
\title{Tensor Product for SIR Model (A * X * B')}
\usage{
cpp_tprod_A_X_Bt(X, A, B)
}
\arguments{
\item{X}{Three-dimensional array (m x m x T) representing the network state over time.
Each slice X[,,t] is the network at time t that carries influence.}

\item{A}{Matrix (m x m) of sender effects. Element A[i,k] represents how node i
is influenced by the sending behavior of node k.}

\item{B}{Matrix (m x m) of receiver effects. Element B[j,l] represents how node j's
reception is modified by node l's receiving patterns.}
}
\value{
Three-dimensional array (m x m x T) where element [i,j,t] represents the
  total bilinear influence from node i to node j at time t.
}
\description{
Performs the bilinear transformation central to the Social Influence Regression model.
Computes A * X_t * B' for each time slice t, where this product represents how
network influence flows through the sender effects (A) and receiver effects (B).
}
\details{
This operation is the computational bottleneck of the SIR model, appearing in both
the likelihood evaluation and gradient computation. The function implements:

For each time t: Result[,,t] = A * X[,,t] * B'

Where:
- A captures sender-specific influence patterns (how nodes affect others)
- B captures receiver-specific influence patterns (how nodes are affected)
- X typically contains lagged network outcomes that carry influence forward

Mathematical interpretation:
- Element (i,j) of the result represents the total influence flowing from i to j
- This influence is mediated by the entire network structure at time t
- The bilinear form allows for complex, indirect influence pathways

Computational optimizations:
- Pre-computes B' once rather than for each time slice
- Uses Armadillo's optimized BLAS routines for matrix multiplication
- Memory-aware slice-wise operations to avoid large temporary matrices
- Compiler optimizations enabled through RcppArmadillo
}
\note{
This function is called repeatedly during optimization, so efficiency is critical.
  The implementation avoids unnecessary memory allocations and leverages BLAS Level 3
  operations for optimal performance.
}
\examples{
\dontrun{
// In R:
m <- 10; T <- 5
X <- array(rnorm(m*m*T), dim=c(m,m,T))
A <- matrix(rnorm(m*m), m, m)
B <- matrix(rnorm(m*m), m, m)
result <- cpp_tprod_A_X_Bt(X, A, B)
}

}
